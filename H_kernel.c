/***********************************************************************************************************************
* 注：应该只有一个短任务（最长的运行时间大于为时标间隔的%50，尽可能的短）可以强占运行，否则将削弱系统的整体性能。推荐使用合作式内核
***********************************************************************************************************************/


#include <stdio.h>
#include <stdint.h>
#include "H_kernel.h"

static Task_t SCH_tasks[SCH_MAX_TASKS] = {0};
static void (*Idle_Hook)(void);


/***********************************************************************************************************************
* @param hook:指定的钩子函数
***********************************************************************************************************************/
void SCH_Idle_Sethook(void (*hook)(void))
{
    Idle_Hook = hook;
}

/***********************************************************************************************************************
 * @brief 此功能放入定时器里面进行更新，刷新任务队列
 ***********************************************************************************************************************/
void SCH_Update(void)
{
    /* 任务时间片处理 */
    uint8_t Index;
    for (Index = 0; Index < SCH_MAX_TASKS; Index++)
    {
        /* 检查这里是否有任务  */
        if (SCH_tasks[Index].pTask)
        {
            if (SCH_tasks[Index].Delay == 0)
            {
                /* 如果是任务式合作式的 */
                if ( SCH_tasks[Index].Co_op)
                {
                    /* "RunMe" 标志加 1 */
                    SCH_tasks[Index].RunMe += 1;
                }
                /* 如果是任务式合作式的 */
                else
                {
                    /* 直接运行函数 */
                    SCH_tasks[Index].pTask();
                    /* RunMe标志复位减1 */
                    //SCH_tasks[Index].RunMe -= 1;
                    /* 如果是单次任务，将任务删除 */
                    if (SCH_tasks[Index].Period == 0)
                    {
                        SCH_tasks[Index].pTask = NULL;
                    }
                }

                if (SCH_tasks[Index].Period)
                {
                    /* 调度定期的任务再次运行 */
                    SCH_tasks[Index].Delay = SCH_tasks[Index].Period;
                }
            }
            else
            {
                /* 任务还未准备好，延时减 1 */
                SCH_tasks[Index].Delay -= 1;
            }
        }
    }
}

/***********************************************************************************************************************
 * @brief    清空第Index个任务块
 * @param Index: 任务的节点号
 ***********************************************************************************************************************/
void SCH_Clear_Task(const uint8_t Index)
{
    SCH_tasks[Index].pTask = NULL;
    SCH_tasks[Index].Delay = 0;
    SCH_tasks[Index].Period = 0;
    SCH_tasks[Index].RunMe = 0;
    /* Co_op 可不做处理 */
    SCH_tasks[Index].Co_op = 0;
}

/***********************************************************************************************************************
 * @brief    调度任务初始化，用于准备调度器
 ***********************************************************************************************************************/
void SCH_Init(void)
{
    uint8_t Index;
    for (Index = 0; Index < SCH_MAX_TASKS; Index++)
    {
        SCH_Clear_Task(Index);
    }
}

/***********************************************************************************************************************
 * @brief    向调度器增加任务函数
 * @param pTask:指向任务的指针
 * @param Delay:任务初始延迟
 * @param Period:连续运行之间的间隔
 * @param Co_op:合作式和抢占式内核的标志,如果是任务式合作式的，设置为1,如果是抢占式合作式的，设置为0
 * @return uint8_t: >=SCH_MAX_TASKS时, 说明任务队列已满，出现了错误
***********************************************************************************************************************/
uint8_t SCH_Add_Task(void (*pTask)(void), const uint32_t Delay, const uint16_t Period,const uint8_t Co_op)
{
    uint8_t Index = 0; // Index最大为255，所以SCH_MAX_TASKS最大为256

    /* 首先在队列中找到一个空块(如果有的话) */
    while ((SCH_tasks[Index].pTask != NULL) && (Index < SCH_MAX_TASKS))
    {
        Index++;
    }
    /* 到达队尾,此时已经有了错误，任务太多 */
    if (Index == SCH_MAX_TASKS) 
    {
        return SCH_MAX_TASKS;
    }

    /* 如果运行到这，说明任务队列中有空间 */
    /* 先清空，再赋值 */
    SCH_Clear_Task(Index); 

    SCH_tasks[Index].pTask = pTask;
    SCH_tasks[Index].Delay = Delay;
    SCH_tasks[Index].Period = Period;
    SCH_tasks[Index].Co_op = Co_op;
    SCH_tasks[Index].RunMe = 0;
    return Index;
}

/***********************************************************************************************************************
 * @brief    删除节点处的任务
 * @param Index:任务的节点
 * @return uint8_t: 0xFF-fail
 ***********************************************************************************************************************/
uint8_t SCH_Delete_Task(const uint8_t Index)
{
    uint8_t Return_code;
    /* 这里没有任务 */
    if (SCH_tasks[Index].pTask == NULL) 
    {
        Return_code = 0xFF;
    }
    else // 这里有任务...
    {
        SCH_Clear_Task(Index);
        Return_code = Index;
    }
    return Return_code;
}

/***********************************************************************************************************************
 * @brief    任务运行，此任务一旦运行永不回头
 ***********************************************************************************************************************/
void SCH_Dispatch_Tasks(void)
{
    uint8_t Index;
    /* 一旦启动多任务调度将永不返回 */
    while (1)
    {
        for (Index = 0; Index < SCH_MAX_TASKS; Index++)
        {
            /* 如果当前任务是合作式任务且已就绪 */
            if ((SCH_tasks[Index].Co_op)&&(SCH_tasks[Index].RunMe > 0))
            {
                /* 运行该任务 */
                SCH_tasks[Index].pTask();
                SCH_tasks[Index].RunMe -= 1;
                /* 如果是单次任务，将它从队列里面删除 */
                if (SCH_tasks[Index].Period == 0)
                {
                    SCH_Delete_Task(Index);
                }
            }
        }
        /* 空闲任务 */
		if(Idle_Hook != 0)
		{
            Idle_Hook();
		}
        /* 系统应答状态，根据实际情况添加 */
        //SCH_Report_Status();
    }
}


/***********************************************************************************************************************
* @brief    功能函数1，100ms运行周期
***********************************************************************************************************************/
void fun1_100ms(void)
{

}

/***********************************************************************************************************************
* @brief    功能函数2，200ms运行周期
***********************************************************************************************************************/

void fun2_200ms(void)
{

}

/***********************************************************************************************************************
* @brief    功能函数3，300ms运行周期，抢占式内核
***********************************************************************************************************************/
void fun3_50ms_preemptive(void)
{

}

/***********************************************************************************************************************
* @brief    功能函数4,钩子函数
***********************************************************************************************************************/
void fun4_Idle_Hook(void)
{

}


void User_Init(void)
{

}

int main(int argc, char *argv[])
{
    User_Init();
    SCH_Idle_Sethook(fun4_Idle_Hook);
    SCH_Init();
    SCH_Add_Task(fun1_100ms,0,100,1);
    SCH_Add_Task(fun2_200ms,3,200,1);
    SCH_Add_Task(fun3_50ms_preemptive,5,50,0);

    SCH_Dispatch_Tasks();
}
